import { useEffect, useState } from "react";

export const useTableTaskSettings = () => {
  const [editMode, setEditMode] = useState(false);
  const [selectedTasks, setSelectedTasks] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [lastSelectedCell, setLastSelectedCell] = useState(null); // Store last clicked cell for range selection

  const validCells = [
    "texturing", // Changed to lowercase to match OverviewItem
    "rigging",
    "modeling",
    "shading",
    "animate",
    "light",
  ];

  const toggleTask = (cellId, rowId, departments) => {
    if (!validCells.includes(cellId)) return;

    const theKey = `${rowId}-${cellId}`;
    setSelectedTasks((prev) => {
      if (prev.some((item) => item.key === theKey)) {
        // Deselect if already selected
        return prev.filter((item) => item.key !== theKey);
      }
      // Otherwise select
      return [...prev, { key: theKey, tasks: departments }];
    });
  };

  // Helper function to get all cells in a rectangular range
  const getCellsInRange = (startCell, endCell, allRows) => {
    if (!startCell || !endCell) return [];

    const startRowIndex = allRows.findIndex(
      (row) => row.id.toString() === startCell.rowId
    );
    const endRowIndex = allRows.findIndex(
      (row) => row.id.toString() === endCell.rowId
    );
    const startColIndex = validCells.indexOf(startCell.cellId);
    const endColIndex = validCells.indexOf(endCell.cellId);

    // Ensure we have valid indices
    if (
      startRowIndex === -1 ||
      endRowIndex === -1 ||
      startColIndex === -1 ||
      endColIndex === -1
    ) {
      return [];
    }

    const minRow = Math.min(startRowIndex, endRowIndex);
    const maxRow = Math.max(startRowIndex, endRowIndex);
    const minCol = Math.min(startColIndex, endColIndex);
    const maxCol = Math.max(startColIndex, endColIndex);

    const cellsInRange = [];

    // Generate all combinations within the range
    for (let rowIndex = minRow; rowIndex <= maxRow; rowIndex++) {
      for (let colIndex = minCol; colIndex <= maxCol; colIndex++) {
        const cellId = validCells[colIndex];
        const rowData = allRows[rowIndex];
        const rowId = rowData.id.toString();

        cellsInRange.push({
          key: `${rowId}-${cellId}`,
          cellId,
          rowId,
          tasks: rowData?.departments || [],
        });
      }
    }

    return cellsInRange;
  };

  // FOR SINGLE CLICK - SELECT ONE AND SHOW PREVIEW
  const selectSingleTask = (cellId, rowId, departments) => {
    if (!validCells.includes(cellId)) return false;

    const theKey = `${rowId}-${cellId}`;
    // Clear all selections and select only this one
    setSelectedTasks([{ key: theKey, tasks: departments }]);
    setLastSelectedCell({ cellId, rowId });
    return true; // Return true to indicate preview should be shown
  };

  // FOR CTRL+CLICK - TOGGLE INDIVIDUAL SELECTION
  const toggleSingleTask = (cellId, rowId, departments) => {
    if (!validCells.includes(cellId)) return false;

    const theKey = `${rowId}-${cellId}`;
    const currentCell = { cellId, rowId };

    setSelectedTasks((prev) => {
      const existingIndex = prev.findIndex((item) => item.key === theKey);
      if (existingIndex !== -1) {
        // Cell is selected, deselect it
        return prev.filter((item) => item.key !== theKey);
      } else {
        // Cell is not selected, select it
        return [...prev, { key: theKey, tasks: departments }];
      }
    });

    // Update last selected cell for potential range selection
    setLastSelectedCell(currentCell);
    return false; // Return false to indicate no preview should be shown
  };

  // FOR SHIFT+CLICK - RANGE SELECTION
  const selectRangeTask = (cellId, rowId, departments, allRows = []) => {
    if (!validCells.includes(cellId)) return false;

    const currentCell = { cellId, rowId };

    if (lastSelectedCell) {
      // Range selection with Shift+Click
      const cellsInRange = getCellsInRange(
        lastSelectedCell,
        currentCell,
        allRows
      );

      setSelectedTasks((prev) => {
        // Create a set of existing keys for faster lookup
        const existingKeys = new Set(prev.map((item) => item.key));

        // Check if ALL cells in range are already selected
        const allInRangeSelected = cellsInRange.every((cell) =>
          existingKeys.has(cell.key)
        );

        if (allInRangeSelected) {
          // If all cells in range are selected, deselect them
          const rangeKeys = new Set(cellsInRange.map((cell) => cell.key));
          return prev.filter((item) => !rangeKeys.has(item.key));
        } else {
          // If some or none are selected, select all in range
          const newSelections = cellsInRange.filter(
            (cell) => !existingKeys.has(cell.key)
          );
          return [...prev, ...newSelections];
        }
      });
    } else {
      // First shift+click without previous selection - just select this cell
      const theKey = `${rowId}-${cellId}`;
      setSelectedTasks([{ key: theKey, tasks: departments }]);
      setLastSelectedCell(currentCell);
    }
    return false; // Return false to indicate no preview should be shown
  };

  // FOR SHIFT+CTRL+CLICK - EXTEND SELECTION RANGE WITHOUT DESELECTING EXISTING
  const extendSelectionRange = (cellId, rowId, departments, allRows = []) => {
    if (!validCells.includes(cellId)) return false;

    const currentCell = { cellId, rowId };

    if (lastSelectedCell) {
      // Range selection with Shift+Ctrl+Click
      const cellsInRange = getCellsInRange(
        lastSelectedCell,
        currentCell,
        allRows
      );

      setSelectedTasks((prev) => {
        // Create a set of existing keys for faster lookup
        const existingKeys = new Set(prev.map((item) => item.key));

        // Always add new cells to selection (don't deselect if all are selected)
        const newSelections = cellsInRange.filter(
          (cell) => !existingKeys.has(cell.key)
        );
        return [...prev, ...newSelections];
      });
    } else {
      // First shift+ctrl+click without previous selection - just select this cell
      const theKey = `${rowId}-${cellId}`;
      setSelectedTasks((prev) => {
        const existingIndex = prev.findIndex((item) => item.key === theKey);
        if (existingIndex === -1) {
          return [...prev, { key: theKey, tasks: departments }];
        }
        return prev;
      });
      setLastSelectedCell(currentCell);
    }
    return false; // Return false to indicate no preview should be shown
  };

  // Main handler that determines which selection method to use
  const handleTaskSelection = (
    cellId,
    rowId,
    departments,
    allRows,
    isShiftClick,
    isCtrlClick
  ) => {
    if (isShiftClick && isCtrlClick) {
      // Shift+Ctrl+Click - extend range without deselecting existing
      return extendSelectionRange(cellId, rowId, departments, allRows);
    } else if (isShiftClick) {
      // Shift+Click - range selection
      return selectRangeTask(cellId, rowId, departments, allRows);
    } else if (isCtrlClick) {
      // Ctrl+Click - toggle individual
      return toggleSingleTask(cellId, rowId, departments);
    } else {
      // Normal click - single selection with preview
      return selectSingleTask(cellId, rowId, departments);
    }
  };

  // Legacy function for backward compatibility
  const selectedMultipleTasks = (
    cellId,
    rowId,
    departments,
    allRows = [],
    isShiftClick = false,
    isCtrlClick = false
  ) => {
    return handleTaskSelection(
      cellId,
      rowId,
      departments,
      allRows,
      isShiftClick,
      isCtrlClick
    );
  };

  // FOR EDIT MODE (deprecated but keeping for compatibility)
  const taskHandleMouseDown = (cellId, rowId) => {
    if (!editMode) return;
    setIsDragging(true);
    toggleTask(cellId, rowId, []);
  };

  const taskHandleMouseEnter = (cellId, rowId) => {
    if (!editMode || !isDragging) return;
    toggleTask(cellId, rowId, []);
  };

  const taskHandleMouseUp = () => {
    if (!editMode) return;
    setIsDragging(false);
  };

  const isTaskSelected = (cellId, rowId) => {
    const theKey = `${rowId}-${cellId}`;
    return selectedTasks.some((item) => item.key === theKey);
  };

  // Clear all selections
  const clearSelection = () => {
    setSelectedTasks([]);
    setLastSelectedCell(null);
  };

  // Select all valid tasks in given rows
  const selectAllTasks = (allRows) => {
    const allTasks = [];
    allRows.forEach((row) => {
      validCells.forEach((cellId) => {
        allTasks.push({
          key: `${row.id}-${cellId}`,
          tasks: row.departments || [],
        });
      });
    });
    setSelectedTasks(allTasks);
  };

  useEffect(() => {
    console.log("Selected tasks:", selectedTasks);
  }, [selectedTasks]);

  useEffect(() => {
    setSelectedTasks([]);
    setLastSelectedCell(null);
  }, [editMode]);

  return {
    editMode,
    setEditMode,
    isDragging,
    taskHandleMouseDown,
    taskHandleMouseEnter,
    taskHandleMouseUp,
    isTaskSelected,
    selectedTasks,
    setSelectedTasks,
    selectedMultipleTasks,
    selectSingleTask,
    toggleSingleTask,
    selectRangeTask,
    extendSelectionRange,
    handleTaskSelection,
    clearSelection,
    selectAllTasks,
    lastSelectedCell,
  };
};
