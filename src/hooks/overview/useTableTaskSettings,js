import { useEffect, useState } from "react";

export const useTableTaskSettings = () => {
  const [editMode, setEditMode] = useState(false);
  const [selectedTasks, setSelectedTasks] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [lastSelectedCell, setLastSelectedCell] = useState(null);

  const validCells = [
    "texturing",
    "rigging",
    "modeling",
    "shading",
    "animate",
    "light",
  ];

  const toggleTask = (cellId, rowId, departments, entityId, typeId = null) => {
    if (!validCells.includes(cellId)) return;

    const theKey = `${rowId}-${cellId}`;
    setSelectedTasks((prev) => {
      if (prev.some((item) => item.key === theKey)) {
        return prev.filter((item) => item.key !== theKey);
      }

      const departmentTask = departments?.[cellId] || {};

      return [
        ...prev,
        {
          key: theKey,
          cellId,
          rowId,
          entityId,
          typeId,
          departmentTask,
          allDepartments: departments,
        },
      ];
    });
  };

  const getCellsInRange = (startCell, endCell, allRows, typeId = null) => {
    if (!startCell || !endCell) return [];

    const startRowIndex = allRows.findIndex(
      (row) => row.id.toString() === startCell.rowId
    );
    const endRowIndex = allRows.findIndex(
      (row) => row.id.toString() === endCell.rowId
    );
    const startColIndex = validCells.indexOf(startCell.cellId);
    const endColIndex = validCells.indexOf(endCell.cellId);

    if (
      startRowIndex === -1 ||
      endRowIndex === -1 ||
      startColIndex === -1 ||
      endColIndex === -1
    )
      return [];

    const minRow = Math.min(startRowIndex, endRowIndex);
    const maxRow = Math.max(startRowIndex, endRowIndex);
    const minCol = Math.min(startColIndex, endColIndex);
    const maxCol = Math.max(startColIndex, endColIndex);

    const cellsInRange = [];

    for (let rowIndex = minRow; rowIndex <= maxRow; rowIndex++) {
      for (let colIndex = minCol; colIndex <= maxCol; colIndex++) {
        const cellId = validCells[colIndex];
        const rowData = allRows[rowIndex];
        const rowId = rowData.id.toString();
        const departments = rowData?.departments || {};
        const departmentTask = departments[cellId] || {};

        cellsInRange.push({
          key: `${rowId}-${cellId}`,
          cellId,
          rowId,
          entityId: rowData?.id,
          typeId,
          departmentTask,
          allDepartments: departments,
        });
      }
    }

    return cellsInRange;
  };

  const selectSingleTask = (cellId, rowId, departments, entityId, typeId = null) => {
    if (!validCells.includes(cellId)) return false;

    const theKey = `${rowId}-${cellId}`;
    const departmentTask = departments?.[cellId] || {};

    setSelectedTasks([
      {
        key: theKey,
        cellId,
        rowId,
        entityId,
        typeId,
        departmentTask,
        allDepartments: departments,
        selectedAt: Date.now(), // Add timestamp for selection order
      },
    ]);
    setLastSelectedCell({ cellId, rowId });
    return true;
  };

  const toggleSingleTask = (cellId, rowId, departments, entityId, typeId = null) => {
    if (!validCells.includes(cellId)) return false;

    const theKey = `${rowId}-${cellId}`;
    const departmentTask = departments?.[cellId] || {};
    const currentCell = { cellId, rowId };

    setSelectedTasks((prev) => {
      const existingIndex = prev.findIndex((item) => item.key === theKey);
      if (existingIndex !== -1) {
        return prev.filter((item) => item.key !== theKey);
      } else {
        return [
          ...prev,
          {
            key: theKey,
            cellId,
            rowId,
            entityId,
            typeId,
            departmentTask,
            allDepartments: departments,
            selectedAt: Date.now(), // Add timestamp for selection order
          },
        ];
      }
    });

    setLastSelectedCell(currentCell);
    return false;
  };

  const selectRangeTask = (cellId, rowId, departments, allRows = [], typeId = null) => {
    if (!validCells.includes(cellId)) return false;

    const currentCell = { cellId, rowId };

    if (lastSelectedCell) {
      const cellsInRange = getCellsInRange(
        lastSelectedCell,
        currentCell,
        allRows,
        typeId
      );

      setSelectedTasks((prev) => {
        const existingKeys = new Set(prev.map((item) => item.key));
        const allInRangeSelected = cellsInRange.every((cell) =>
          existingKeys.has(cell.key)
        );

        if (allInRangeSelected) {
          const rangeKeys = new Set(cellsInRange.map((cell) => cell.key));
          return prev.filter((item) => !rangeKeys.has(item.key));
        } else {
          const newSelections = cellsInRange.filter(
            (cell) => !existingKeys.has(cell.key)
          );
          return [...prev, ...newSelections];
        }
      });
    } else {
      const theKey = `${rowId}-${cellId}`;
      const departmentTask = departments?.[cellId] || {};

      setSelectedTasks([
        {
          key: theKey,
          cellId,
          rowId,
          entityId: allRows.find((r) => r.id.toString() === rowId)?.id,
          typeId,
          departmentTask,
          allDepartments: departments,
        },
      ]);
      setLastSelectedCell(currentCell);
    }
    return false;
  };

  const extendSelectionRange = (cellId, rowId, departments, allRows = [], typeId = null) => {
    if (!validCells.includes(cellId)) return false;

    const currentCell = { cellId, rowId };

    if (lastSelectedCell) {
      const cellsInRange = getCellsInRange(
        lastSelectedCell,
        currentCell,
        allRows,
        typeId
      );

      setSelectedTasks((prev) => {
        const existingKeys = new Set(prev.map((item) => item.key));
        const newSelections = cellsInRange.filter(
          (cell) => !existingKeys.has(cell.key)
        );
        return [...prev, ...newSelections];
      });
    } else {
      const theKey = `${rowId}-${cellId}`;
      const departmentTask = departments?.[cellId] || {};
      const entityId = allRows.find((r) => r.id.toString() === rowId)?.id;

      setSelectedTasks((prev) => {
        const existingIndex = prev.findIndex((item) => item.key === theKey);
        if (existingIndex === -1) {
          return [
            ...prev,
            {
              key: theKey,
              cellId,
              rowId,
              entityId,
              typeId,
              departmentTask,
              allDepartments: departments,
            },
          ];
        }
        return prev;
      });
      setLastSelectedCell(currentCell);
    }
    return false;
  };

  const handleTaskSelection = (
    e,
    cellId,
    rowId,
    entName,
    departments,
    allRows,
    isShiftClick,
    isCtrlClick,
    entityId,
    typeId = null
  ) => {
    e.stopPropagation();
    
    if (isShiftClick && isCtrlClick) {
      return extendSelectionRange(cellId, rowId, departments, allRows, typeId);
    } else if (isShiftClick) {
      return selectRangeTask(cellId, rowId, departments, allRows, typeId);
    } else if (isCtrlClick) {
      return toggleSingleTask(cellId, rowId, departments, entityId, typeId);
    } else {
      return selectSingleTask(cellId, rowId, departments, entityId, typeId);
    }
  };

  const selectedMultipleTasks = (
    cellId,
    rowId,
    departments,
    allRows = [],
    isShiftClick = false,
    isCtrlClick = false,
    entityId,
    typeId = null
  ) => {
    return handleTaskSelection(
      cellId,
      rowId,
      departments,
      allRows,
      isShiftClick,
      isCtrlClick,
      entityId,
      typeId
    );
  };

  const taskHandleMouseDown = (cellId, rowId) => {
    if (!editMode) return;
    setIsDragging(true);
    toggleTask(cellId, rowId, [], null);
  };

  const taskHandleMouseEnter = (cellId, rowId) => {
    if (!editMode || !isDragging) return;
    toggleTask(cellId, rowId, [], null);
  };

  const taskHandleMouseUp = () => {
    if (!editMode) return;
    setIsDragging(false);
  };

  const isTaskSelected = (cellId, rowId) => {
    const theKey = `${rowId}-${cellId}`;
    return selectedTasks.some((item) => item.key === theKey);
  };

  const clearSelection = () => {
    setSelectedTasks([]);
    setLastSelectedCell(null);
  };

  const setTypeIdForAllSelected = (typeId) => {
    setSelectedTasks((prev) => 
      prev.map((task) => ({
        ...task,
        typeId
      }))
    );
  };

  const selectAllTasks = (allRows, typeId = null) => {
    const allTasks = [];
    allRows.forEach((row) => {
      const departments = row.departments || {};
      validCells.forEach((cellId) => {
        const departmentTask = departments[cellId] || {};
        allTasks.push({
          key: `${row.id}-${cellId}`,
          cellId,
          rowId: row.id.toString(),
          entityId: row.id,
          typeId,
          departmentTask,
          allDepartments: departments,
        });
      });
    });
    setSelectedTasks(allTasks);
  };

  useEffect(() => {
    setSelectedTasks([]);
    setLastSelectedCell(null);
  }, [editMode]);

  return {
    editMode,
    setEditMode,
    isDragging,
    taskHandleMouseDown,
    taskHandleMouseEnter,
    taskHandleMouseUp,
    isTaskSelected,
    selectedTasks,
    setSelectedTasks,
    selectedMultipleTasks,
    selectSingleTask,
    toggleSingleTask,
    selectRangeTask,
    extendSelectionRange,
    handleTaskSelection,
    clearSelection,
    selectAllTasks,
    setTypeIdForAllSelected,
    lastSelectedCell,
  };
};